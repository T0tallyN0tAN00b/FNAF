<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Night Watch — FNAF-Inspired</title>
<style>
  :root {
    --bg: #0b0f14;
    --panel: #111827;
    --panel2: #0f172a;
    --accent: #38bdf8;
    --accent2: #f59e0b;
    --danger: #ef4444;
    --ok: #22c55e;
    --text: #e5e7eb;
    --muted: #94a3b8;
  }
  html, body { height: 100%; background: var(--bg); color: var(--text); margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji','Segoe UI Emoji'; }
  #ui { display: grid; grid-template-columns: 1fr 360px; gap: 16px; padding: 16px; height: 100%; box-sizing: border-box; }
  /* Office view */
  #office {
    position: relative; background: linear-gradient(#0b0f14 45%, #0d141d); border: 1px solid #223; border-radius: 8px; overflow: hidden;
  }
  .grain { position: absolute; inset: 0; background-image: radial-gradient(rgba(255,255,255,0.02), transparent 60%); mix-blend-mode: overlay; pointer-events: none; }
  .statusbar {
    position: absolute; top: 0; left: 0; right: 0; display: flex; gap: 12px; align-items: center;
    padding: 8px 12px; background: rgba(10,14,20,0.6); border-bottom: 1px solid #1b2533; backdrop-filter: blur(2px);
  }
  .statusbar .item { font-size: 14px; color: var(--muted); }
  .statusbar .value { color: var(--text); font-weight: 600; margin-left: 6px; }
  .time { margin-left: auto; }
  /* Doors */
  .door { position: absolute; top: 0; bottom: 0; width: 120px; background: linear-gradient(180deg,#0f172a,#0b1220); border-left: 2px solid #162032; border-right: 2px solid #162032; transition: transform 0.2s ease; }
  #doorLeft { left: 0; transform: translateX(-100%); }
  #doorRight { right: 0; transform: translateX(100%); }
  .door.closed { transform: translateX(0); }
  .doorLabel { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); font-size: 12px; color: var(--muted); }
  /* Office desk and buttons */
  .desk {
    position: absolute; left: 50%; bottom: 0; transform: translateX(-50%);
    width: 92%; height: 120px; background: linear-gradient(#0d1320,#0a101a); border-top: 1px solid #1a2232;
  }
  .controls {
    position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 12px; flex-wrap: wrap; justify-content: center;
  }
  button {
    background: var(--panel); color: var(--text); border: 1px solid #263246; border-radius: 8px; padding: 10px 14px; cursor: pointer;
    font-weight: 600; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.2);
  }
  button:hover { background: #162032; }
  button.toggle.on { outline: 2px solid var(--accent); }
  button.danger.on { outline: 2px solid var(--danger); }
  .hint { text-align: center; font-size: 12px; color: var(--muted); margin-top: 6px; }
  /* Camera monitor */
  #monitor {
    position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);
    width: 82%; height: 64%; background: #0a0f16; border: 1px solid #1a2232; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.35);
    display: none;
  }
  #monitor.on { display: block; }
  .monitorTop { display: flex; gap: 8px; padding: 8px; background: rgba(10,14,20,0.8); border-bottom: 1px solid #1a2232; }
  .camsGrid { display: grid; grid-template-columns: repeat(3,1fr); gap: 8px; padding: 8px; height: calc(100% - 44px); box-sizing: border-box; }
  .camTile {
    position: relative; background: linear-gradient(180deg,#0b1018,#0d141d); border: 1px solid #1a2232; border-radius: 8px; overflow: hidden;
  }
  .camName { position: absolute; left: 8px; bottom: 8px; font-size: 12px; color: var(--muted); }
  .signal { position: absolute; right: 8px; top: 8px; font-size: 11px; color: var(--accent2); }
  .entity { position: absolute; width: 18px; height: 18px; border-radius: 50%; background: var(--danger); filter: drop-shadow(0 0 6px rgba(239,68,68,0.55)); transition: transform 0.4s ease; }
  /* Power meter */
  .meter {
    display: inline-flex; gap: 4px; align-items: center; padding: 4px 8px; background: #0d141d; border: 1px solid #1a2232; border-radius: 6px;
  }
  .bar { width: 140px; height: 8px; background: #132030; border-radius: 6px; overflow: hidden; }
  .barFill { height: 100%; width: 100%; background: linear-gradient(90deg, #22c55e, #f59e0b, #ef4444); transition: width 0.25s; }
  /* Jumpscare overlay */
  #overlay {
    position: fixed; inset: 0; background: black; display: none; align-items: center; justify-content: center; z-index: 99;
  }
  #overlay.show { display: flex; animation: flicker 0.12s linear infinite alternate; }
  @keyframes flicker { from { opacity: 0.95 } to { opacity: 1 } }
  .overlayText { color: #ff2b2b; font-size: 44px; font-weight: 900; letter-spacing: 2px; text-shadow: 0 0 12px rgba(255,43,43,0.5); }
  /* Win overlay */
  #win { position: fixed; inset: 0; background: rgba(10,14,20,0.9); display: none; align-items: center; justify-content: center; z-index: 90; }
  #win.show { display: flex; }
  .winCard { background: #0c121c; border: 1px solid #1a2232; border-radius: 12px; padding: 16px 20px; text-align: center; }
  .winCard h2 { margin: 0 0 8px 0; }
  .sub { color: var(--muted); font-size: 13px; margin-bottom: 10px; }
</style>
</head>
<body>
<div id="ui">
  <div id="office">
    <div class="grain"></div>
    <div class="statusbar">
      <div class="item">Power
        <span class="meter"><span class="bar"><span class="barFill" id="powerFill"></span></span></span>
      </div>
      <div class="item">Usage<span class="value" id="usage">0</span></div>
      <div class="item">Noise<span class="value" id="noise">Low</span></div>
      <div class="item time">Time<span class="value" id="clock">12:00 AM</span></div>
    </div>
    <div id="doorLeft" class="door"><div class="doorLabel">LEFT DOOR</div></div>
    <div id="doorRight" class="door"><div class="doorLabel">RIGHT DOOR</div></div>

    <div id="monitor">
      <div class="monitorTop">
        <button id="closeMonitor">Close monitor</button>
        <div class="hint">Click a camera tile to focus. Entities move when you’re on cameras.</div>
      </div>
      <div class="camsGrid" id="cams">
        <!-- 3x3 cameras -->
      </div>
    </div>

    <div class="controls">
      <button id="btnCam" class="toggle">Camera monitor [C]</button>
      <button id="btnLeft" class="toggle danger">Left door [A]</button>
      <button id="btnRight" class="toggle danger">Right door [D]</button>
      <button id="btnLightL">Left light [Q]</button>
      <button id="btnLightR">Right light [E]</button>
    </div>
    <div class="desk"></div>
  </div>

  <div id="panel" style="background: var(--panel2); border: 1px solid #1a2232; border-radius: 8px; padding: 12px;">
    <h3 style="margin-top:0;">Instructions</h3>
    <ul>
      <li><strong>Survive:</strong> Make it to 6:00 AM with power remaining.</li>
      <li><strong>Monitor:</strong> Toggle cameras with C. Entities move faster while you watch cameras.</li>
      <li><strong>Doors:</strong> Close A/D to block attacks. Doors drain power.</li>
      <li><strong>Lights:</strong> Tap Q/E to check door corners. Lights add noise and minor power drain.</li>
      <li><strong>Power:</strong> Higher usage drains faster. When power hits 0, doors open and attacks are likely.</li>
    </ul>
    <div class="hint">Tip: Don’t ride the monitor too long—listen to “Noise” and watch “Usage”.</div>
    <hr style="border-color:#1a2232;">
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button id="btnStart">Start night</button>
      <button id="btnReset">Reset</button>
      <button id="btnHard">Hard mode</button>
    </div>
    <p class="hint">Hard mode: faster enemy routes, higher passive drain.</p>
  </div>
</div>

<div id="overlay"><div class="overlayText">JUMPSCARE</div></div>
<div id="win">
  <div class="winCard">
    <h2>6:00 AM</h2>
    <div class="sub">You survived the night.</div>
    <button onclick="resetGame()">Play again</button>
  </div>
</div>

<script>
/* --- Game state --- */
const state = {
  running: false,
  hard: false,
  timeMinutes: 0,          // 0..360 -> 12AM..6AM
  power: 100,              // percent
  usage: 0,                // 0..5
  noise: 0,                // 0..3
  leftDoor: false,
  rightDoor: false,
  lightL: false,
  lightR: false,
  monitorOn: false,
  focusedCam: 0,
  // Entities: each has route of cam indices and attack side
  entities: [
    { name:'Red', route:[0,1,2,5,8], side:'R', pos:0, cooldown:0 },
    { name:'Blue', route:[6,7,4,3,0], side:'L', pos:0, cooldown:0 },
    { name:'Golden', route:[2,4,6,4,2], side: Math.random()<0.5?'L':'R', pos:0, cooldown:0 }
  ],
  attackTimerL: 0,
  attackTimerR: 0,
  powerOut: false
};

const ui = {
  powerFill: document.getElementById('powerFill'),
  usage: document.getElementById('usage'),
  noise: document.getElementById('noise'),
  clock: document.getElementById('clock'),
  doorLeft: document.getElementById('doorLeft'),
  doorRight: document.getElementById('doorRight'),
  btnCam: document.getElementById('btnCam'),
  btnLeft: document.getElementById('btnLeft'),
  btnRight: document.getElementById('btnRight'),
  btnLightL: document.getElementById('btnLightL'),
  btnLightR: document.getElementById('btnLightR'),
  monitor: document.getElementById('monitor'),
  camsGrid: document.getElementById('cams'),
  overlay: document.getElementById('overlay'),
  win: document.getElementById('win'),
  btnStart: document.getElementById('btnStart'),
  btnReset: document.getElementById('btnReset'),
  btnHard: document.getElementById('btnHard'),
  closeMonitor: document.getElementById('closeMonitor'),
};

/* --- Build camera grid --- */
const CAM_COUNT = 9;
const camTiles = [];
for (let i=0;i<CAM_COUNT;i++){
  const tile = document.createElement('div'); tile.className='camTile';
  const name = document.createElement('div'); name.className='camName'; name.textContent = `CAM ${i+1}`;
  const sig = document.createElement('div'); sig.className='signal'; sig.textContent = 'LIVE';
  const entity = document.createElement('div'); entity.className='entity'; entity.style.display='none';
  tile.appendChild(name); tile.appendChild(sig); tile.appendChild(entity);
  tile.addEventListener('click', ()=>{ state.focusedCam=i; flashTile(tile); });
  ui.camsGrid.appendChild(tile);
  camTiles.push({tile, entity});
}
function flashTile(tile){
  tile.style.outline = `2px solid ${getAccent()}`;
  setTimeout(()=> tile.style.outline = 'none', 250);
}

/* --- Input bindings --- */
ui.btnCam.onclick = ()=> toggleMonitor();
ui.closeMonitor.onclick = ()=> setMonitor(false);
ui.btnLeft.onclick = ()=> setDoor('L', !state.leftDoor);
ui.btnRight.onclick = ()=> setDoor('R', !state.rightDoor);
ui.btnLightL.onclick = ()=> pulseLight('L');
ui.btnLightR.onclick = ()=> pulseLight('R');
ui.btnStart.onclick = startGame;
ui.btnReset.onclick = resetGame;
ui.btnHard.onclick = ()=> { state.hard = !state.hard; ui.btnHard.textContent = state.hard ? 'Hard mode: ON' : 'Hard mode'; resetGame(); };

document.addEventListener('keydown', (e)=>{
  if (e.key.toLowerCase()==='c') toggleMonitor();
  if (e.key.toLowerCase()==='a') setDoor('L', !state.leftDoor);
  if (e.key.toLowerCase()==='d') setDoor('R', !state.rightDoor);
  if (e.key.toLowerCase()==='q') pulseLight('L');
  if (e.key.toLowerCase()==='e') pulseLight('R');
});

/* --- Core loop --- */
let rafId = null, lastTs = 0;
function startGame(){
  if (state.running) return;
  state.running = true;
  ui.btnStart.textContent = 'Night in progress';
  lastTs = performance.now();
  rafId = requestAnimationFrame(loop);
}
function resetGame(){
  cancelAnimationFrame(rafId); rafId = null;
  Object.assign(state, {
    running:false, timeMinutes:0, power:100, usage:0, noise:0, leftDoor:false, rightDoor:false,
    lightL:false, lightR:false, monitorOn:false, focusedCam:0, powerOut:false, attackTimerL:0, attackTimerR:0
  });
  state.entities = [
    { name:'Red', route:[0,1,2,5,8], side:'R', pos:0, cooldown:0 },
    { name:'Blue', route:[6,7,4,3,0], side:'L', pos:0, cooldown:0 },
    { name:'Golden', route:[2,4,6,4,2], side: Math.random()<0.5?'L':'R', pos:0, cooldown:0 }
  ];
  setDoor('L', false); setDoor('R', false);
  setMonitor(false);
  ui.overlay.classList.remove('show');
  ui.win.classList.remove('show');
  ui.btnStart.textContent = 'Start night';
  renderHUD();
  renderCams();
}
function loop(ts){
  const dt = Math.min(0.05, (ts - lastTs)/1000); // seconds cap
  lastTs = ts;
  if (!state.running) return;
  updateTime(dt);
  updateEntities(dt);
  updatePower(dt);
  checkAttacks(dt);
  renderHUD();
  renderCams();
  if (state.power<=0 && !state.powerOut){
    state.powerOut = true;
    // Open doors and turn off lights/monitor automatically
    setDoor('L', false); setDoor('R', false); setMonitor(false);
  }
  // Win condition
  if (state.timeMinutes >= 360 && !state.powerOut){
    state.running = false; ui.win.classList.add('show');
  }
  rafId = requestAnimationFrame(loop);
}

/* --- Systems --- */
function updateTime(dt){
  // 60 real seconds -> 6 minutes game -> 6 hours (ratio ~1h/min)
  const rate = state.hard ? 6.5 : 6.0; // minutes per 60s
  state.timeMinutes += dt * rate;
  // Format clock (12:00 AM to 6:00 AM)
  const totalMin = Math.floor(state.timeMinutes);
  const hour = 12 + Math.floor(totalMin/60);
  const minute = (totalMin % 60).toString().padStart(2,'0');
  ui.clock.textContent = `${hour}:` + `${minute} ` + `AM`;
}

function updatePower(dt){
  // Base drain
  let drain = state.hard ? 0.08 : 0.06;
  // Usage components
  const doorDrain = (state.leftDoor?0.09:0) + (state.rightDoor?0.09:0);
  const lightDrain = (state.lightL?0.03:0) + (state.lightR?0.03:0);
  const monitorDrain = state.monitorOn ? 0.05 : 0;
  drain += doorDrain + lightDrain + monitorDrain;
  // Noise reflects lights/monitor
  const noiseLevel = (state.monitorOn?1:0) + (state.lightL?1:0) + (state.lightR?1:0);
  state.noise = Math.min(3, noiseLevel);
  // Usage: number of active systems
  state.usage = (state.leftDoor?1:0) + (state.rightDoor?1:0) + (state.lightL?1:0) + (state.lightR?1:0) + (state.monitorOn?1:0);
  state.power = Math.max(0, state.power - drain*dt*100); // percent per sec
}

function updateEntities(dt){
  const accel = state.monitorOn ? (state.hard ? 1.5 : 1.25) : 1.0;
  // Each entity moves along route occasionally
  for (const ent of state.entities){
    ent.cooldown -= dt * accel;
    if (ent.cooldown <= 0){
      const baseCd = state.hard ? 6 : 8;
      ent.cooldown = baseCd + Math.random()*baseCd; // random cadence
      ent.pos = Math.min(ent.route.length-1, ent.pos + 1);
    }
  }
}

function checkAttacks(dt){
  // If entity reaches end of route, they approach door side and build attack timer
  for (const ent of state.entities){
    if (ent.pos >= ent.route.length-1){
      if (ent.side==='L'){
        state.attackTimerL += dt * (state.hard ? 1.6 : 1.2);
        // Left door closed blocks attack, slows timer
        if (state.leftDoor) state.attackTimerL = Math.max(0, state.attackTimerL - dt*2.0);
      } else {
        state.attackTimerR += dt * (state.hard ? 1.6 : 1.2);
        if (state.rightDoor) state.attackTimerR = Math.max(0, state.attackTimerR - dt*2.0);
      }
    }
  }
  // Lights briefly reveal attackers and reduce their buildup
  if (state.lightL) state.attackTimerL = Math.max(0, state.attackTimerL - dt*0.8);
  if (state.lightR) state.attackTimerR = Math.max(0, state.attackTimerR - dt*0.8);
  // If power out, attacks spike
  if (state.powerOut){
    state.attackTimerL += dt*1.3;
    state.attackTimerR += dt*1.3;
  }
  // Trigger jumpscare threshold
  const threshold = state.hard ? 3.5 : 4.2;
  if (state.attackTimerL > threshold || state.attackTimerR > threshold){
    jumpscare();
  }
}

/* --- UI actions --- */
function setDoor(side, on){
  if (side==='L'){ state.leftDoor = !!on; ui.doorLeft.classList.toggle('closed', !!on); ui.btnLeft.classList.toggle('on', !!on); }
  if (side==='R'){ state.rightDoor = !!on; ui.doorRight.classList.toggle('closed', !!on); ui.btnRight.classList.toggle('on', !!on); }
}
function setMonitor(on){
  state.monitorOn = !!on;
  ui.monitor.classList.toggle('on', !!on);
  ui.btnCam.classList.toggle('on', !!on);
}
function toggleMonitor(){ setMonitor(!state.monitorOn); }
function pulseLight(side){
  const key = side==='L' ? 'lightL' : 'lightR';
  state[key] = true;
  renderHUD();
  setTimeout(()=>{ state[key] = false; renderHUD(); }, 600);
}

/* --- Render --- */
function renderHUD(){
  ui.powerFill.style.width = `${Math.max(0, Math.min(100, state.power))}%`;
  ui.usage.textContent = state.usage;
  ui.noise.textContent = state.noise===0?'Low':state.noise===1?'Medium':'High';
  ui.btnLightL.classList.toggle('on', state.lightL);
  ui.btnLightR.classList.toggle('on', state.lightR);
}
function renderCams(){
  // Place entities at their current cam positions
  for (let i=0;i<camTiles.length;i++){
    camTiles[i].entity.style.display = 'none';
  }
  for (const ent of state.entities){
    const camIndex = ent.route[ent.pos];
    const tile = camTiles[camIndex];
    const e = tile.entity;
    e.style.display = 'block';
    const x = 8 + Math.random()*140, y = 8 + Math.random()*80;
    e.style.transform = `translate(${x}px, ${y}px)`;
  }
}

/* --- Outcomes --- */
function jumpscare(){
  state.running = false;
  ui.overlay.classList.add('show');
  setTimeout(()=> ui.overlay.classList.remove('show'), 1500);
  // Reset after scare
  setTimeout(()=> resetGame(), 1600);
}

/* --- Helpers --- */
function getAccent(){ return ['#38bdf8','#a78bfa','#f472b6','#f59e0b'][Math.floor(Math.random()*4)] }

/* --- Init --- */
resetGame();
</script>
</body>
</html>
